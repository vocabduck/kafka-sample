public class EsalesDBServiceImpl implements EsalesDBService {

    private static final Logger logger = LoggerFactory.getLogger(EsalesDBServiceImpl.class);

    @Autowired
    private final EsalesISGDataRepository esalesISGDataRepository;

    @Autowired
    private final EsalesISGDataArchiveRepository esalesISGDataArchiveRepository;

    @Autowired
    private final DimAccountService dimAccountService;

    public EsalesDBServiceImpl(EsalesISGDataRepository esalesISGDataRepository,
                               EsalesISGDataArchiveRepository esalesISGDataArchiveRepository) {
        this.esalesISGDataRepository = esalesISGDataRepository;
        this.esalesISGDataArchiveRepository = esalesISGDataArchiveRepository;
    }

    @Transactional
    public void persist(List<EsalesGoldDto> esalesGoldDtoList) {
        if (esalesGoldDtoList == null || esalesGoldDtoList.isEmpty()) return;

        List<EsalesData> toAdd = new ArrayList<>();
        List<EsalesData> toDelete = new ArrayList<>();
        List<EsalesDataArchive> toArchive = new ArrayList<>();

        Map<String, EsalesGoldDto> dtoMap = new HashMap<>();

        for (EsalesGoldDto dto : esalesGoldDtoList) {
            if (dto != null && dto.getMnemonic() != null) {
                dtoMap.put(dto.getMnemonic(), dto);
            }
        }

        if (dtoMap.isEmpty()) return;

        List<String> mnemonics = new ArrayList<>(dtoMap.keySet());
        List<EsalesData> existingData = esalesISGDataRepository.findByEsalesDataKeyAccountMnemonic(mnemonics);
        Set<String> existingIds = existingData.stream()
                .map(data -> data.getEsalesDataKey().getMnemonic())
                .collect(Collectors.toSet());

        String user = System.getProperty("user.name", "system");
        Timestamp now = Timestamp.valueOf(LocalDateTime.now());

        for (Map.Entry<String, EsalesGoldDto> entry : dtoMap.entrySet()) {
            String mnemonic = entry.getKey();
            EsalesGoldDto dto = entry.getValue();

            EsalesData entity = AMCGoldDtoMapper.INSTANCE.toEntity(dto);

            if (existingIds.contains(mnemonic)) {
                Optional<EsalesData> existing = existingData.stream()
                        .filter(e -> mnemonic.equals(e.getEsalesDataKey().getMnemonic()))
                        .findFirst();

                existing.ifPresent(orig -> {
                    EsalesDataArchive archive = AMCGoldDtoToArchiveMapper.INSTANCE.toEntity(orig);
                    toArchive.add(archive);
                    toDelete.add(orig);

                    entity.setCreatedBy(orig.getCreatedBy());
                    entity.setCreatedDDT(orig.getCreatedDDT());
                });
            } else {
                entity.setCreatedBy(user);
                entity.setCreatedDDT(now);
            }

            entity.setModifiedBy(user);
            entity.setModifiedDDT(now);
            toAdd.add(entity);
        }

        try {
            if (!toArchive.isEmpty()) {
                List<EsalesDataArchive> archived = esalesISGDataArchiveRepository.saveAll(toArchive);
                logger.info("{} REF Account Archive records saved.", archived.size());
            } else {
                logger.info("No REF Account Archive data to save.");
            }

            if (!toDelete.isEmpty()) {
                esalesISGDataRepository.deleteAll(toDelete);
                logger.info("{} REF Account records deleted.", toDelete.size());
            } else {
                logger.info("No REF Account records to delete.");
            }

            if (!toAdd.isEmpty()) {
                List<EsalesData> added = esalesISGDataRepository.saveAll(toAdd);
                logger.info("{} REF Account records saved.", added.size());
            } else {
                logger.info("No REF Account records to add.");
            }

            dimAccountService.persistAccounts(toAdd);

        } catch (DataAccessException e) {
            logger.error("Saving REF_AMC_ACCOUNT and REF_AMC_ACCOUNT_ARCHIVE failed.", e);
            // TODO: Handle retry logic if required
        }
    }
}
